rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Funções auxiliares
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }
    
    // Verifica se é admin olhando para a coleção professionals
    // Valida se o documento existe E se tem role admin ou superAdmin
    function isAdmin() {
       let docPath = /databases/$(database)/documents/professionals/$(request.auth.uid);
       return request.auth != null && exists(docPath) && (get(docPath).data.role == 'admin' || get(docPath).data.superAdmin == true);
    }

    // Regra global de bloqueio por defeito - Segurança Máxima
    match /{document=**} {
      allow read, write: if false; 
    }

    // PROFISSIONAIS (Perfil público para leitura, escrita por owner/admin)
    match /professionals/{userId} {
      allow read: if true; // Perfil é público
      allow write: if isOwner(userId) || isAdmin();

      // SERVIÇOS
      match /services/{serviceId} {
        allow read: if true;
        allow write: if isOwner(userId) || isAdmin();
      }
      
      // MARCAÇÕES (BOOKINGS) - Raiz do profissional
      match /bookings/{bookingId} {
        // Validação na criação: data e serviço obrigatórios
        allow create: if true 
           && request.resource.data.keys().hasAll(['date', 'serviceId', 'clientName'])
           && request.resource.data.date is string;
           
        // Leitura permitida publicamente para cálculo de disponibilidade (frontend)
        // Em produção de alta segurança, usar Backend/Edge Functions para verificar slots.
        allow read: if true; 
        allow update, delete: if isOwner(userId) || isAdmin();
      }

      // STAFF E SUAS SUB-COLEÇÕES
      match /staff/{staffId} {
        allow read: if true;
        
        // Escrita: Owner (userId da rota), Admin, ou o próprio Staff (valido pelo authUserId no doc existente ou no payload novos)
        allow write: if isOwner(userId) || isAdmin() || (resource != null && resource.data.authUserId == request.auth.uid) || (request.resource.data.authUserId == request.auth.uid);

        // Configurações do Staff (Horários)
        match /settings/{docId} {
             allow read: if true;
             // Validar parent staff authUserId é complexo em queries, mas ok em gets diretos
             allow write: if isOwner(userId) || isAdmin() || get(/databases/$(database)/documents/professionals/$(userId)/staff/$(staffId)).data.authUserId == request.auth.uid;
        }

        // MARCAÇÕES DO STAFF
        match /bookings/{bookingId} {
            allow create: if true
               && request.resource.data.keys().hasAll(['date', 'serviceId']);
            allow read: if true; 
            allow update, delete: if isOwner(userId) || isAdmin() || get(/databases/$(database)/documents/professionals/$(userId)/staff/$(staffId)).data.authUserId == request.auth.uid;
        }
      }
      
       // SETTINGS GERAIS (Horários do dono)
      match /settings/{document=**} {
         allow read: if true;
         allow write: if isOwner(userId) || isAdmin();
      }
    }
    
    // CLIENTES
    match /clients/{clientId} {
        allow create: if true;
        // Cliente só mexe nos dados dele
        allow read, update: if request.auth != null && request.auth.uid == clientId;
    }

    // STAFF LOOKUP - Mapeamento para login
    match /staff_lookup/{authUid} {
      allow read: if request.auth != null;
      // Qualquer auth user pode criar o seu lookup (no setup)
      allow create: if request.auth != null; 
      // Update/Delete só pelo dono associado ao doc (não o authUid, mas quem gere) ou o próprio
      allow update, delete: if request.auth != null && (resource.data.ownerId == request.auth.uid || request.auth.uid == authUid);
    }
  }
}
